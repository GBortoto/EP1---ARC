# Exercício de programação - ACH2055 - Arquitetura de Computadores
# Docente:	Prof. Dr. Clodoaldo Aparecido
#
# Dicentes:	Alex Alves da Silva Bognar	927698
#		Álex Santana Fogaça		9360732
#		Guilherme Bortoto de Moraes	9360760
#		Juliana Mayumi Suzuki		9277691
#------------------------------------------------------------------------------------------

.data
array1: .space 4000			# Espaço alocado para o primeiro array
array2: .space 8000			# Espaço alocado para o segundo array
arrayResposta: .space 12000		# Espaço alocado para o terceiro array
bufferForWritting: .space 4		# Buffer utilizado para escrever arquivos no disco
filename1: .asciiz "arquivo1.txt"	# Nome do arquivo de entrada 1
filename2: .asciiz "arquivo2.txt"	# Nome do arquivo de entrada 2
OutputFileName: .asciiz "resultado.txt"	# Nome do arquivo de saída
buffer: .asciiz ""			# Buffer utilizado para ler arquivos do disco
pulaLinha: .asciiz "\n"			# Utilizado para os prints

#------------------------------------------------------------------------------------------
.text
la $s1, buffer		# Buffer utilizado para ler arquivos do disco 
la $s2, array1		# array1
addi $s3,$zero,0	# array1 size
la $s4, array2		# array2
addi $s5,$zero,0	# array2 size
la $s7, pulaLinha	# Utilizado para os prints
#------------------------------------------------------------------------------------------
addi $t1,$zero,0

LerPrimeiroArray:
la $t3, filename1
li   $v0, 13        # system call for open file
add $a0,$zero,$t3   # input file name
li   $a1, 0         # flag for reading
li   $a2, 0         # mode is ignored
syscall             # open a file 
move $s0, $v0       # save the file descriptor 
addi $t2,$zero,0
j read

LerSegundoArray:
la $s1, buffer
addi $t1,$zero,0 # i

la $t3, filename2
li   $v0, 13        # system call for open fileopen file
add $a0,$zero,$t3   # input file name
li   $a1, 0        # flag for reading
li   $a2, 0        # mode is ignored
syscall            # open a file 
move $s0, $v0      # save the file descriptor 
addi $t2,$zero,0

# -----------------------------------------------------------------------------------------
# read
# Essa função lê o próximo byte em arquivo e o retorna
# Lê: Byte em arquivo, codificado em ASCII
read:
addi $t7,$zero,0
# reading from file just opened
li   $v0, 14       # system call for reading from file
move $a0, $s0      # file descriptor 
la   $a1, buffer   # address of buffer from which to read
add $a2,$t2,1
#li   $a2, $t0	   # hardcoded buffer length
syscall            # read from file

add $t3,$t2,$s1
lb $t1, 0($t3)
j Translate

# -----------------------------------------------------------------------------------------
# Translate
# Essa função recebe o valor ASCII lido do arquivo através do registrador $t0
# e o traduz para um valor inteiro, guardando-o em $t4.
# Após a tradução, chama a função ASCII_To_Word, a qual escreve na memória o valor em $t4
# Essa função também traduz "-" e "\n"

Translate:
beq $t1,10,Enter		# "\n"	ASCII: 10
addi $t4,$zero,0
beq $t1,48,ASCII_To_Word	# "0"	ASCII: 48
addi $t4,$zero,1
beq $t1,49,ASCII_To_Word	# "1"	ASCII: 49
addi $t4,$zero,2
beq $t1,50,ASCII_To_Word	# "2"	ASCII: 50
addi $t4,$zero,3
beq $t1,51,ASCII_To_Word	# "3"	ASCII: 51
addi $t4,$zero,4
beq $t1,52,ASCII_To_Word	# "4"	ASCII: 52
addi $t4,$zero,5
beq $t1,53,ASCII_To_Word	# "5"	ASCII: 53
addi $t4,$zero,6
beq $t1,54,ASCII_To_Word	# "6"	ASCII: 54
addi $t4,$zero,7
beq $t1,55,ASCII_To_Word	# "7"	ASCII: 55
addi $t4,$zero,8
beq $t1,56,ASCII_To_Word	# "8"	ASCII: 56
addi $t4,$zero,9
beq $t1,57,ASCII_To_Word	# "9"	ASCII: 57

beq $t1,45,Minus		# "-"	ASCII: 45

beq $t1,32,Space		# " "	ASCII: 32
j Error

# -----------------------------------------------------------------------------------------
# Error
# Caso exista algum caractere desconhecido, terminar programa
Error:
j END2

# -----------------------------------------------------------------------------------------
# Space
# Ignorar espaços
Space:
addi $t8,$zero,0	# 
addi $s3,$s3,1
j read

# -----------------------------------------------------------------------------------------
# Minus
# Caso o caracter lido for "-"
Minus:
addi $t8,$zero,0	# 
addi $t9,$zero,1	# settar a flag para negativos $t9
j read

# -----------------------------------------------------------------------------------------
# Enter
# Caso o caracter lido for "\n"
Enter:
bgtz $t8, EndOfFile	# Dois "\n" em seguida --> Arquivo finalizado
addi $s3,$s3,1		# Passar para próxima palavra (aka o número acabou)
addi $t8,$t8,1		# Flag para "O último caracter foi um "\n" "
bgtz $t9, Negative	# Preciso tornar o número negativo?
j read

# -----------------------------------------------------------------------------------------
# Negative
# Caso a flag $t9 seja verdadeira ao final de um número,
# torne esse número em memória negativo
Negative:
subi $t0,$s3,1
sll $t0,$t0,2
add $t0,$t0,$s2
lw $t1,($t0)		# $t1 = ultimo número em memória
addi $t3,$zero,-1
mult $t1,$t3
mflo $t1
sw $t1,0($t0)
addi $t9,$zero,0	# Resetar Flag "negativo"
j read

# -----------------------------------------------------------------------------------------
# ASCII_To_Word
# Essa função recebe o número a ser adicionado na memória através do registrador $t4
ASCII_To_Word:
addi $t8,$zero,0
sll $t0,$s3,2
add $t0,$t0,$s2
lw $t1,0($t0)		# $t1 = valor atual na memória

add $a0,$zero,$t4	# argumento 1 = Valor a ser adicionar
add $a1,$zero,$t1	# argumento 2 = Valor já existente na memória
jal LidarComDecimal	# Chamar a função LidarComDecimal(argumento1,argumento2)
add $t1,$zero,$v0	# $t1 = resultado da função
sw $t1,0($t0)		# Gravar $t1 na memória
j read

# -----------------------------------------------------------------------------------------
# LidarComDecimal
# Essa função pega o valor armazenado na memória, o multiplica por 10 e adiciona o valor
# a ser inserido
# Ex:	a0 = 123	v0 = 123 * 10 + 4 = 1230 + 4 = 1234
#	a1 = 4
LidarComDecimal:
addi $t5,$zero,0
beqz $a1,skip

addi $t6,$zero,10
mult $a1,$t6
mflo $t5

skip:			# Se o valor na memória for 0, só adicione o novo valor
add $v0,$t5,$a0
jr $ra


# -----------------------------------------------------------------------------------------
# EndOfFile
# Essa função é chamada quando o arquivo é visto como finalizado ("\n\n")

EndOfFile:
add $a0,$zero,$s0
li $v0, 16		# Fechar arquivo
syscall
    
addi $t1,$zero,0	# i = 0
addi $t2,$zero,0	# place holder
subi $s3,$s3,1		# Devido a forma como o programa define o fim do arquivo,
			# é necessário remover 1 do total de elementos no arquivo.

printArray:		# Mostrar todo o array
sll $t2,$t1,2
add $t2,$t2,$s2
lw $t0, 0($t2)		# $t0 = array[i]
jal printValor		# print(t0)

bge $t1,$s3, FimPrintArray	# if(i >= array.length) FimPrintArray
addi $t1,$t1,1		# i++
j printArray

FimPrintArray:
li $v0,4		# print "\n"
move $a0,$s7
syscall

bgtz $s5, TrocaDeVolta		# Caso o programa já tenha lido o segundo arquivo,
				# o tamanho do array secundário (array1) vai ser
				# maior do que 0. Nesse caso, destroque os arrays.
				# Se não, inverta os arrays e leia o segundo arquivo.

# -----------------------------------------------------------------------------------------
# Swap
# Essa parte do código troca os arrays 1 e 2 de lugar, exibindo a configuração seguinte:
# array1		$s2	-->	array2			$s2
# tam.array1		$s3	-->	tam.array2		$s3
# array2		$s4	-->	array1			$s4
# tam.array2		$s5	-->	tam.array1		$s5
Swap:
add $t0,$zero,$s2	# Guarda $s2
add $t1,$zero,$s3	# Guarda $s3

add $s2,$zero,$s4	# $s2 = array2
add $s3,$zero,$s5	# $s3 = tam.array2

add $s4,$zero,$t0	# $s4 = array1
add $s5,$zero,$t1	# $s5 = tam.array1
j LerSegundoArray


# -----------------------------------------------------------------------------------------
# TrocaDeVolta:
# Essa função retoma a posição original dos arrays, exibindo a configuração seguinte:
# array2		$s2	-->	array1			$s2
# tam.array2		$s3	-->	tam.array1		$s3
# array1		$s4	-->	array2			$s4
# tam.array1		$s5	-->	tam.array2		$s5

TrocaDeVolta:
add $t0,$zero,$s2	# Guarda $s2
add $t1,$zero,$s3	# Guarda $s3

add $s2,$zero,$s4	# $s2 = array1
add $s3,$zero,$s5	# $s3 = tam.array1

add $s4,$zero,$t0	# $s4 = array2
add $s5,$zero,$t1	# $s5 = tam.array2
j END

# -----------------------------------------------------------------------------------------
# printValor:
# Essa função recebe um valor em $t0 e o exibe no terminal
printValor:
li $v0,1	# print array[i]
move $a0,$t0
syscall

li $v0,4	# print " "
move $a0,$s7
syscall
jr $ra


END:


# -----------------------------------------------------------------------------------------
# Final da primeira parte do programa:
# Ler os dois arquivos e armazena-los em memória

# -----------------------------------------------------------------------------------------
# Resentando e organizando tudo

addi $v0,$zero,0
addi $v1,$zero,0

addi $a0,$zero,0
addi $a1,$zero,0
addi $a2,$zero,0
addi $a3,$zero,0

addi $t0,$zero,0
addi $t1,$zero,0
addi $t2,$zero,0
addi $t3,$zero,0
addi $t4,$zero,0
addi $t5,$zero,0
addi $t6,$zero,0
addi $t7,$zero,0
addi $t8,$zero,0
addi $t9,$zero,0

add $s0,$zero,$s2
add $s1,$zero,$s3
add $s2,$zero,$s4
add $s3,$zero,$s5
addi $s4,$zero,0
addi $s5,$zero,0
addi $s6,$zero,0
addi $s7,$zero,0


# PARTE 2
# Pegar esses dois arquivos armazenados e armazena-los em um terceiro array,
# ordenando-os no processo e retirando repetições
# -----------------------------------------------------------------------------------------


# array[]		$s0
# array.length - 1	$s1
# array2[]		$s2
# array2.length - 1	$s3
# \n			$s5
# resposta[]		$s6
# resposta.length - 1 	$s7

la $s4, bufferForWritting
la $s5, pulaLinha
la $s6, arrayResposta
addi $s7,$zero,-1
#----------------------------------------------------------------------

# fill(array)
addi $t1,$zero,0
addi $t0,$zero,0 # i
Fill3:
bge $t0,10, EndFill3 # while i < 10
sll $t2,$t0,2
add $t2,$t2,$s6
sw $t1,0($t2)	# array[i] = 0
addi $t0,$t0,1 # i++
j Fill3
EndFill3:


addi $t0,$s1,1 # t0 = s1 + 1 --> array.length  - 1 + 1 = array.length
addi $t1,$s3,1 # t1 = s3 + 1 --> array2.length - 1 + 1 = array2.length

add $a0,$zero,$t0 # int *tam1
add $a1,$zero,$s0 # int *vetor1
add $a2,$zero,$t1 # int *tam2
add $a3,$zero,$s2 # int *vetor2
# Chama a função "concatena"
jal concatena

# Armazena os valores retornados
add $s6,$zero,$v0 # $s6 = array resposta
add $s7,$zero,$v1 # $s7 = tamanho do array resposta - 1

file_open:
    li $v0, 13
    la $a0, OutputFileName
    li $a1, 1
    li $a2, 0
    syscall  # File descriptor gets returned in $v0

add $t9,$zero,$v0

addi $t1,$zero,0
addi $t2,$zero,0
printArrayFinal:
sll $t2,$t1,2
add $t2,$t2,$s6
lw $t0, 0($t2)

add $t7,$zero,$t0
add $t8,$zero,$t1
jal NumberToASCII
add $t0,$zero,$t7
add $t1,$zero,$t8

add $t7,$zero,$s4
addi $t6,$zero,10
sw $t6,0($t7)

# Pular linha
file_write:
    move $a0, $t9  # Syscall 15 requieres file descriptor in $a0
    li $v0, 15
    add $a1,$zero,$t7
    la $a2, 1
    syscall

jal printValor2

bge $t1,$s7, FimPrintArrayFinal	# if(i >= array.length) FimPrint
addi $t1,$t1,1
j printArrayFinal

FimPrintArrayFinal:
li $v0,4	# print "\n"
move $a0,$s5
syscall
j END2

NumberToASCII:
add $t3,$zero,$t0
addi $t1,$zero,0
addi $t2,$zero,10
addi $t4,$zero,1

bltz $t0, NTANegativo
j loop

NTANegativo:

add $t2,$zero,$s4
addi $t6,$zero,45
sw $t6,0($t2)

move $a0, $t9  # Syscall 15 requieres file descriptor in $a0
li $v0, 15
add $a1,$zero,$t2
la $a2, 1
syscall
addi $t2,$zero,10

addi $t4,$zero,-1
mult $t4,$t0
mflo $t0
j NumberToASCII

loop:
addi $t1,$t1,1
div $t3,$t2
mfhi $t3
addi $t3,$t3,48
subi $sp,$sp,4
sw $t3, 0($sp)
mflo $t3
bgtz $t3, loop


loop2:
subi $t1,$t1,1
lw $t6, 0($sp)
addi $sp,$sp,4
add $t3,$zero,$s4
sw $t6,0($t3)

move $a0, $t9  # Syscall 15 requieres file descriptor in $a0
li $v0, 15
add $a1,$zero,$t3
la $a2, 1
syscall

bgtz $t1, loop2

EndNumberToASCII:
addi $t0,$zero,0
addi $t1,$zero,0
addi $t2,$zero,0
addi $t3,$zero,0
addi $t4,$zero,0
   
jr $ra

concatena:
subi $sp,$sp,32		# Aumenta a pilha em 7 palavras
sw $t0,28($sp)		# Salva o valor atual de t0
sw $t1,24($sp)		# Salva o valor atual de t1
sw $t2,20($sp)		# Salva o valor atual de t2
sw $t3,16($sp)		# Salva o valor atual de t3
sw $t4,12($sp)		# Salva o valor atual de t4
sw $t5,8($sp)		# Salva o valor atual de t5
sw $t6,4($sp)		# Salva o valor atual de t6
sw $t7,0($sp)		# Salva o valor atual de t7

# Recebe
# a0 = s1 = tamanho do array 1
# a1 = s0 = array 1
# a2 = s3 = tamanho do array 2
# a3 = s2 = array 2

addi $t0,$zero,0 # i --> posição no array[]
addi $t1,$zero,0 # j --> posição no array2[]
addi $t2,$zero,0 # tmp (place holder)
addi $t3,$zero,0 # array[i]
addi $t4,$zero,0 # array2[j]
addi $t5,$zero,-1 # tamanho array resposta
la $t6, arrayResposta # array resposta

check:
slt $t2,$t0,$a0			# if(i < array.length) continue checando
beqz $t2, ArrayUmVazio
slt $t2,$t1,$a2
beqz $t2, ArrayDoisVazio	# if(j < array2.length) continue checando

sll $t2,$t0,2
add $t2,$t2,$a1
lw $t3,0($t2)		# t3 = array[i]
sll $t2,$t1,2
add $t2,$t2,$a3
lw $t4,0($t2)		# t4 = array2[j]


seq $t2,$t3,$t4		# Se array[i] == array2[j]
beq $t2,1,Equal
slt $t2,$t3,$t4		# Se array[i] < array2[j]
beq $t2,1,Less
j Greater		# Se array[i] > array2[j]

Equal:
sll $t2,$t5,2
add $t2,$t2,$t6
lw $t7,0($t2)		# t7 = resposta[-1]
seq $t2,$t7,$t3
bnez $t2, NaoAdicionar

addi $t5,$t5,1
sll $t2,$t5,2
add $t2,$t2,$t6
sw $t3,0($t2)

NaoAdicionar:
addi $t0,$t0,1 # i++
addi $t1,$t1,1 # j++
j check

Less:
sll $t2,$t5,2
add $t2,$t2,$t6
lw $t7,0($t2)		# t7 = resposta[-1]
seq $t2,$t7,$t3
bnez $t2, NaoAdicionarI

add $t5,$t5,1
sll $t2,$t5,2
add $t2,$t2,$t6
sw $t3,0($t2)

NaoAdicionarI:
addi $t0,$t0,1 # i++
j check

Greater:
sll $t2,$t5,2
add $t2,$t2,$t6
lw $t7,0($t2)		# t7 = resposta[-1]
seq $t2,$t7,$t4
bnez $t2, NaoAdicionarJ

add $t5,$t5,1
sll $t2,$t5,2
add $t2,$t2,$t6
sw $t4,0($t2)

NaoAdicionarJ:
addi $t1,$t1,1 # j++
j check

ArrayUmVazio:
slt $t2,$t1,$a2
beqz $t2, Fim	# if(j >= array2.length) Fim

sll $t2,$t5,2
add $t2,$t2,$t6
lw $t7,0($t2)		# t7 = resposta[-1]

sll $t2,$t1,2
add $t2,$t2,$a3
lw $t4,0($t2)		# t4 = array2[j]

beq $t7,$t4, NaoAdicionarJ2

add $t5,$t5,1
sll $t2,$t5,2
add $t2,$t2,$t6
sw $t4,0($t2)

NaoAdicionarJ2:
addi $t1,$t1,1 # j++
j ArrayUmVazio


ArrayDoisVazio:
slt $t2,$t0,$a0
beqz $t2, Fim	# if(i >= array.length) Fim

sll $t2,$t5,2
add $t2,$t2,$t6
lw $t7,0($t2)		# t7 = resposta[-1]

sll $t2,$t0,2
add $t2,$t2,$a1
lw $t3,0($t2)		# t3 = array[i]

beq $t7,$t3, NaoAdicionarI2

add $t5,$t5,1
sll $t2,$t5,2
add $t2,$t2,$t6
sw $t3,0($t2)

NaoAdicionarI2:
addi $t0,$t0,1 # i++
j ArrayDoisVazio

Fim:
add $v0,$zero,$t6 # retorno 1 - Array resposta
add $v1,$zero,$t5 # retorno 2 - Tamanho do array resposta

lw $t7,0($sp)		# Repoe o valor original de t7
lw $t6,4($sp)		# Repoe o valor original de t6
lw $t5,8($sp)		# Repoe o valor original de t5
lw $t4,12($sp)		# Repoe o valor original de t4
lw $t3,16($sp)		# Repoe o valor original de t3
lw $t2,20($sp)		# Repoe o valor original de t2
lw $t1,24($sp)		# Repoe o valor original de t1
lw $t0,28($sp)		# Repoe o valor original de t0
addi $sp,$sp,32		# Diminui a pilha em 8 palavras
jr $ra

j END2

printValor2:
li $v0,1	# print array[i]
move $a0,$t0
syscall

li $v0,4	# print " "
move $a0,$s5
syscall
jr $ra

END2:
addi $v0,$zero,0
addi $v1,$zero,0

addi $a0,$zero,0
addi $a1,$zero,0
addi $a2,$zero,0
addi $a3,$zero,0

addi $t0,$zero,0
addi $t1,$zero,0
addi $t2,$zero,0
addi $t3,$zero,0
addi $t4,$zero,0
addi $t5,$zero,0
addi $t6,$zero,0
addi $t7,$zero,0
addi $t8,$zero,0
addi $t9,$zero,0

add $s4,$zero,$s6
add $s5,$zero,$s7
addi $s6,$zero,0
addi $s7,$zero,0